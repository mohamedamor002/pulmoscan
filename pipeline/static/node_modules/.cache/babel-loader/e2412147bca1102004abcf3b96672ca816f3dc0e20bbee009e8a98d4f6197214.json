{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kouss\\\\Desktop\\\\Cursor\\\\Segmentation\\\\pipeline\\\\webapp\\\\static\\\\src\\\\components\\\\InteractiveViewer.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { ArrowPathIcon, ExclamationCircleIcon } from '@heroicons/react/24/outline';\nimport { useTheme } from '../contexts/ThemeContext';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst InteractiveViewer = ({\n  caseId,\n  selectedNoduleId,\n  resultsPageView = false,\n  onNoduleClick\n}) => {\n  _s();\n  const [volumeInfo, setVolumeInfo] = useState(null);\n  const [currentAxis, setCurrentAxis] = useState('axial');\n  const [currentSlice, setCurrentSlice] = useState(0);\n  const [sliceImage, setSliceImage] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [nodulesInSlice, setNodulesInSlice] = useState([]);\n  const [selectedNoduleState, setSelectedNoduleState] = useState(selectedNoduleId);\n  const imageRef = useRef(null);\n  const containerRef = useRef(null);\n  const {\n    darkMode\n  } = useTheme();\n\n  // Update local state when prop changes\n  useEffect(() => {\n    setSelectedNoduleState(selectedNoduleId);\n  }, [selectedNoduleId]);\n\n  // Get the auth token from localStorage\n  const getAuthToken = () => {\n    return localStorage.getItem('token');\n  };\n\n  // Setup axios request with auth headers\n  const createAuthorizedRequest = () => {\n    const token = getAuthToken();\n    return {\n      headers: token ? {\n        'Authorization': `Bearer ${token}`\n      } : {}\n    };\n  };\n\n  // Function to go to a specific nodule slice\n  const goToNoduleSlice = noduleId => {\n    if (!volumeInfo || !volumeInfo.nodules) return;\n\n    // Find the selected nodule in the list\n    const nodule = volumeInfo.nodules.find(n => n.id === noduleId);\n    if (!nodule) {\n      console.error(`Nodule with ID ${noduleId} not found`);\n      return;\n    }\n\n    // Update the selected nodule state\n    setSelectedNoduleState(noduleId);\n\n    // Navigate to appropriate slice based on current view axis\n    if (currentAxis === 'axial') {\n      // For axial view, go to the Z coordinate of the nodule\n      const zSlice = Math.min(Math.max(0, Math.round(nodule.z)), getMaxSliceIndex());\n      setCurrentSlice(zSlice);\n    } else if (currentAxis === 'coronal') {\n      // For coronal view, go to the Y coordinate of the nodule\n      const ySlice = Math.min(Math.max(0, Math.round(nodule.y)), getMaxSliceIndex());\n      setCurrentSlice(ySlice);\n    } else if (currentAxis === 'sagittal') {\n      // For sagittal view, go to the X coordinate of the nodule\n      const xSlice = Math.min(Math.max(0, Math.round(nodule.x)), getMaxSliceIndex());\n      setCurrentSlice(xSlice);\n    }\n\n    // Log the navigation\n    console.log(`Navigated to nodule ${noduleId} at slice ${currentSlice} in ${currentAxis} view`);\n  };\n\n  // Navigate to selected nodule when selectedNoduleId or volumeInfo changes\n  useEffect(() => {\n    if (selectedNoduleId && volumeInfo && volumeInfo.nodules) {\n      goToNoduleSlice(selectedNoduleId);\n    }\n  }, [selectedNoduleId, volumeInfo]);\n\n  // Fetch volume metadata\n  useEffect(() => {\n    const fetchVolumeInfo = async () => {\n      try {\n        setIsLoading(true);\n\n        // Add token to the request\n        const token = getAuthToken();\n        let url = `/api/results/${caseId}/slices`;\n\n        // Add token as query parameter as fallback\n        if (token) {\n          url += `?token=${token}`;\n        }\n        const response = await axios.get(url, createAuthorizedRequest());\n\n        // Check if we received valid volume information\n        if (response.data.volume_info) {\n          setVolumeInfo(response.data.volume_info);\n\n          // Check if we're using placeholder data\n          const usingPlaceholder = response.data.using_placeholder || false;\n          if (usingPlaceholder) {\n            console.warn('Using placeholder data for volume');\n          }\n\n          // Set initial slice to middle of volume\n          const initialSlice = Math.floor(response.data.volume_info.dimensions.depth / 2) || 0;\n          setCurrentSlice(initialSlice);\n\n          // If we're in a simplified view for the results page and there are nodules,\n          // try to show a slice with a nodule if possible\n          if (response.data.volume_info.nodules && response.data.volume_info.nodules.length > 0) {\n            // Find the slice with the most confident nodule\n            const mainNodule = response.data.volume_info.nodules.reduce((prev, current) => current.confidence > prev.confidence ? current : prev, response.data.volume_info.nodules[0]);\n\n            // If there's a selected nodule ID and it matches one of our nodules, use that one\n            if (selectedNoduleId) {\n              const selectedNodule = response.data.volume_info.nodules.find(n => n.id === selectedNoduleId);\n              if (selectedNodule) {\n                // Ensure we're setting a valid number, not NaN\n                const noduleZ = Math.round(selectedNodule.z);\n                if (!isNaN(noduleZ) && noduleZ >= 0 && noduleZ < response.data.volume_info.dimensions.depth) {\n                  setCurrentSlice(noduleZ);\n                  setSelectedNoduleState(selectedNoduleId);\n                }\n              }\n            }\n            // Else if no selected nodule or it wasn't found, navigate to the most confident nodule\n            else {\n              // Ensure we're setting a valid number, not NaN\n              const noduleZ = Math.round(mainNodule.z);\n              if (!isNaN(noduleZ) && noduleZ >= 0 && noduleZ < response.data.volume_info.dimensions.depth) {\n                setCurrentSlice(noduleZ);\n              }\n            }\n          }\n        } else {\n          console.warn('No volume information received from server');\n          // Set default volume info to prevent errors\n          setVolumeInfo({\n            dimensions: {\n              depth: 1,\n              height: 512,\n              width: 512\n            },\n            spacing: [1.0, 1.0, 1.0],\n            nodules: []\n          });\n          setCurrentSlice(0);\n        }\n        setIsLoading(false);\n      } catch (error) {\n        var _error$response, _error$response$data;\n        console.error('Error fetching volume info:', error);\n        setError(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to load volume data');\n        // Set default volume info to prevent errors\n        setVolumeInfo({\n          dimensions: {\n            depth: 1,\n            height: 512,\n            width: 512\n          },\n          spacing: [1.0, 1.0, 1.0],\n          nodules: []\n        });\n        setCurrentSlice(0);\n        setIsLoading(false);\n      }\n    };\n    fetchVolumeInfo();\n  }, [caseId, resultsPageView]);\n\n  // Fetch slice when axis or slice index changes\n  useEffect(() => {\n    const fetchSlice = async () => {\n      if (!volumeInfo) return;\n      try {\n        setIsLoading(true);\n\n        // Add token to the request\n        const token = getAuthToken();\n        let url = `/api/results/${caseId}/slices?axis=${currentAxis}&index=${currentSlice}`;\n\n        // Add token as query parameter as fallback\n        if (token) {\n          url += `&token=${token}`;\n        }\n        const response = await axios.get(url, createAuthorizedRequest());\n\n        // Check if we received a placeholder image\n        const isPlaceholder = response.data.is_placeholder || false;\n\n        // Get the slice data, handling whether it includes the data:image prefix or not\n        let imageData = response.data.slice_data;\n        if (!imageData) {\n          console.error('No slice data received');\n          setError('No image data received from server');\n          setIsLoading(false);\n          return;\n        }\n        if (!imageData.startsWith('data:image')) {\n          imageData = `data:image/png;base64,${imageData}`;\n        }\n\n        // Update max dimension information if available\n        if (response.data.all_dimensions) {\n          // Don't update volumeInfo here as it causes a render loop\n          // Just store the dimensions for reference\n          const allDimensions = {\n            axial: response.data.all_dimensions.axial,\n            coronal: response.data.all_dimensions.coronal,\n            sagittal: response.data.all_dimensions.sagittal\n          };\n\n          // Only update the current max index if needed - this won't trigger a re-render\n          // since we're not updating the volumeInfo state\n          if (allDimensions[currentAxis] && currentSlice > allDimensions[currentAxis] - 1) {\n            setCurrentSlice(allDimensions[currentAxis] - 1);\n          }\n        }\n\n        // If max_index is provided, ensure we're not exceeding it\n        if (response.data.max_index !== undefined && currentSlice > response.data.max_index) {\n          setCurrentSlice(response.data.max_index);\n        }\n        setSliceImage({\n          data: imageData,\n          isPlaceholder: isPlaceholder\n        });\n\n        // If there's an error message, display it but still show the image\n        if (response.data.error || response.data.message) {\n          console.warn('Server returned an error or message:', response.data.error || response.data.message);\n        }\n        setIsLoading(false);\n      } catch (error) {\n        var _error$response2, _error$response2$data, _error$response3, _error$response3$data;\n        console.error('Error fetching slice:', error);\n        setError(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to load slice');\n\n        // Try to display error image if available\n        if ((_error$response3 = error.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.slice_data) {\n          try {\n            let imageData = error.response.data.slice_data;\n            if (!imageData.startsWith('data:image')) {\n              imageData = `data:image/png;base64,${imageData}`;\n            }\n            setSliceImage({\n              data: imageData,\n              isPlaceholder: true\n            });\n          } catch (imgError) {\n            console.error('Error processing error image:', imgError);\n          }\n        }\n        setIsLoading(false);\n      }\n    };\n    fetchSlice();\n  }, [caseId, currentAxis, currentSlice, volumeInfo]);\n\n  // Find nodules in the current slice\n  useEffect(() => {\n    if (!volumeInfo || !volumeInfo.nodules) return;\n\n    // Determine which nodules are visible in this slice\n    const sliceNodules = volumeInfo.nodules.filter(nodule => {\n      // Check if this nodule is visible in the current slice\n      if (currentAxis === 'axial') {\n        // Check if the nodule's z-coordinate is close to this slice\n        return Math.abs(nodule.z - currentSlice) <= nodule.radius;\n      } else if (currentAxis === 'coronal') {\n        // Check if the nodule's y-coordinate is close to this slice\n        return Math.abs(nodule.y - currentSlice) <= nodule.radius;\n      } else {\n        // sagittal\n        // Check if the nodule's x-coordinate is close to this slice\n        return Math.abs(nodule.x - currentSlice) <= nodule.radius;\n      }\n    });\n    setNodulesInSlice(sliceNodules);\n  }, [volumeInfo, currentAxis, currentSlice]);\n\n  // Draw nodule circles and center points when image loads or nodulesInSlice changes\n  useEffect(() => {\n    if (!sliceImage || !imageRef.current || nodulesInSlice.length === 0) return;\n\n    // Skip drawing nodules on placeholder images\n    if (sliceImage.isPlaceholder) return;\n\n    // Check if we're using MHD format with server-rendered nodules\n    const isMhdFormat = caseId && (caseId.endsWith('.mhd') || caseId.includes('1.3.6.1.4.1.14519') ||\n    // LIDC-IDRI format\n    caseId.includes('1.2.826') // DICOM UID format\n    );\n    const drawNodules = () => {\n      // For MHD files with server-rendered nodules, we may not need to draw client-side\n      // Client-side drawing might interfere with server-rendered nodules\n      if (isMhdFormat) {\n        console.log('Using server-rendered nodules for MHD format');\n        // We'll still make the nodules clickable, but won't draw overlays\n        const img = imageRef.current;\n        if (!img.complete) {\n          img.onload = setupNoduleInteractions;\n          return;\n        }\n        setupNoduleInteractions();\n        return;\n      }\n\n      // Normal drawing for non-MHD formats\n      const img = imageRef.current;\n      if (!img.complete) {\n        // Wait for image to load before drawing\n        img.onload = drawNodulesOnImage;\n        return;\n      }\n      drawNodulesOnImage();\n    };\n\n    // This function just makes nodules clickable without drawing SVG overlays\n    const setupNoduleInteractions = () => {\n      const img = imageRef.current;\n      const container = containerRef.current;\n\n      // Create overlay div for event handling\n      const existingOverlay = container.querySelector('.nodule-overlay');\n      if (existingOverlay) {\n        container.removeChild(existingOverlay);\n      }\n\n      // Create a minimal overlay just for handling clicks\n      const overlay = document.createElement('div');\n      overlay.className = 'nodule-overlay';\n      overlay.style.position = 'absolute';\n      overlay.style.top = '0';\n      overlay.style.left = '0';\n      overlay.style.width = '100%';\n      overlay.style.height = '100%';\n      overlay.style.pointerEvents = 'auto';\n\n      // Add click handler for the whole image\n      overlay.addEventListener('click', event => {\n        // Get click coordinates relative to the image\n        const rect = img.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n\n        // Normalize to 0-1 range\n        const xNorm = x / rect.width;\n        const yNorm = y / rect.height;\n\n        // Convert to image coordinates\n        const imgX = Math.round(xNorm * volumeInfo.dimensions.width);\n        const imgY = Math.round(yNorm * volumeInfo.dimensions.height);\n\n        // Find closest nodule to click point\n        let closestNodule = null;\n        let minDistance = Infinity;\n        nodulesInSlice.forEach(nodule => {\n          let nodeX, nodeY;\n          if (currentAxis === 'axial') {\n            nodeX = nodule.x;\n            nodeY = nodule.y;\n          } else if (currentAxis === 'coronal') {\n            nodeX = nodule.x;\n            nodeY = nodule.z;\n          } else {\n            // sagittal\n            nodeX = nodule.y;\n            nodeY = nodule.z;\n          }\n          const distance = Math.sqrt(Math.pow(nodeX - imgX, 2) + Math.pow(nodeY - imgY, 2));\n\n          // Consider a nodule clicked if within 30px of its center\n          if (distance < nodule.radius * 2 && distance < minDistance) {\n            minDistance = distance;\n            closestNodule = nodule;\n          }\n        });\n        if (closestNodule) {\n          setSelectedNoduleState(closestNodule.id);\n          if (onNoduleClick) {\n            onNoduleClick(closestNodule.id);\n          } else {\n            goToNoduleSlice(closestNodule.id);\n          }\n        }\n      });\n      container.appendChild(overlay);\n    };\n\n    // Original function for drawing nodules with SVG overlays\n    const drawNodulesOnImage = () => {\n      const img = imageRef.current;\n      const container = containerRef.current;\n\n      // Clear any existing overlay elements\n      const existingOverlay = container.querySelector('.nodule-overlay');\n      if (existingOverlay) {\n        container.removeChild(existingOverlay);\n      }\n\n      // Create overlay div that will contain the SVG with nodule circles\n      const overlay = document.createElement('div');\n      overlay.className = 'nodule-overlay';\n      overlay.style.position = 'absolute';\n      overlay.style.top = '0';\n      overlay.style.left = '0';\n      overlay.style.width = '100%';\n      overlay.style.height = '100%';\n      overlay.style.pointerEvents = 'auto';\n\n      // Calculate image display dimensions and position\n      const imgRect = img.getBoundingClientRect();\n      const containerRect = container.getBoundingClientRect();\n\n      // Calculate aspect ratio for the current view\n      let aspectRatio = 1.0;\n      if (volumeInfo && volumeInfo.spacing) {\n        if (currentAxis === 'axial') {\n          // Y/X aspect ratio for axial view\n          aspectRatio = volumeInfo.spacing[1] / volumeInfo.spacing[0];\n        } else if (currentAxis === 'coronal') {\n          // Z/X aspect ratio for coronal view\n          aspectRatio = volumeInfo.spacing[2] / volumeInfo.spacing[0];\n        } else {\n          // sagittal\n          // Z/Y aspect ratio for sagittal view\n          aspectRatio = volumeInfo.spacing[2] / volumeInfo.spacing[1];\n        }\n      }\n\n      // Create SVG element for drawing\n      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.setAttribute('width', '100%');\n      svg.setAttribute('height', '100%');\n      svg.style.position = 'absolute';\n      svg.style.top = '0';\n      svg.style.left = '0';\n\n      // Get display dimensions for scaling\n      const displayWidth = imgRect.width;\n      const displayHeight = imgRect.height;\n\n      // Draw each nodule\n      nodulesInSlice.forEach(nodule => {\n        let x, y, slicePos;\n\n        // Calculate 2D coordinates based on the current viewing axis\n        if (currentAxis === 'axial') {\n          x = nodule.x;\n          y = nodule.y;\n          slicePos = currentSlice;\n        } else if (currentAxis === 'coronal') {\n          x = nodule.x;\n          y = nodule.z;\n          slicePos = currentSlice;\n        } else {\n          // sagittal\n          x = nodule.y;\n          y = nodule.z;\n          slicePos = currentSlice;\n        }\n\n        // Calculate the position in normalized coordinates (0-1 range)\n        let xNorm, yNorm;\n        if (currentAxis === 'axial') {\n          xNorm = x / volumeInfo.dimensions.width;\n          yNorm = y / volumeInfo.dimensions.height;\n        } else if (currentAxis === 'coronal') {\n          xNorm = x / volumeInfo.dimensions.width;\n          yNorm = y / volumeInfo.dimensions.depth;\n        } else {\n          // sagittal\n          xNorm = y / volumeInfo.dimensions.height;\n          yNorm = nodule.z / volumeInfo.dimensions.depth;\n        }\n\n        // Apply proper scaling for the current view resolution\n        // Convert from normalized coordinates to display pixels\n        const xPx = xNorm * displayWidth;\n\n        // Apply aspect ratio correction to y-coordinate\n        // This ensures that the nodule appears at the right vertical position\n        // regardless of how the image is stretched or squeezed\n        const yPx = yNorm * displayHeight;\n\n        // Calculate radius in pixels based on the nodule's radius in mm\n        // Scale according to the current display size\n        let radiusMm = nodule.radius || 5; // Default to 5mm if not specified\n        let pixelsPerMm;\n\n        // Calculate pixels per mm based on the current view's spacing\n        if (currentAxis === 'axial') {\n          // Use the minimum of width and height spacing for consistent sizing\n          const spacingX = volumeInfo.spacing ? volumeInfo.spacing[0] : 1;\n          const spacingY = volumeInfo.spacing ? volumeInfo.spacing[1] : 1;\n          const mmPerPixel = Math.min(spacingX, spacingY);\n          // Calculate how many display pixels correspond to one mm in the CT scan\n          const widthInMm = volumeInfo.dimensions.width * spacingX;\n          pixelsPerMm = displayWidth / widthInMm;\n        } else if (currentAxis === 'coronal') {\n          const spacingX = volumeInfo.spacing ? volumeInfo.spacing[0] : 1;\n          const spacingZ = volumeInfo.spacing ? volumeInfo.spacing[2] : 1;\n          const mmPerPixel = Math.min(spacingX, spacingZ);\n          // Calculate how many display pixels correspond to one mm in the CT scan\n          const widthInMm = volumeInfo.dimensions.width * spacingX;\n          pixelsPerMm = displayWidth / widthInMm;\n        } else {\n          // sagittal\n          const spacingY = volumeInfo.spacing ? volumeInfo.spacing[1] : 1;\n          const spacingZ = volumeInfo.spacing ? volumeInfo.spacing[2] : 1;\n          const mmPerPixel = Math.min(spacingY, spacingZ);\n          // Calculate how many display pixels correspond to one mm in the CT scan\n          const heightInMm = volumeInfo.dimensions.height * spacingY;\n          pixelsPerMm = displayHeight / heightInMm;\n        }\n\n        // Calculate the radius in display pixels\n        let radiusPixels = radiusMm * pixelsPerMm;\n\n        // Make circles more appropriately sized for visualization\n        radiusPixels = Math.max(5, radiusPixels * 0.5); // Minimum 5px radius for visibility\n\n        // Adjust the radius based on how far the nodule is from the current slice\n        let distanceFromSlice;\n        if (currentAxis === 'axial') {\n          distanceFromSlice = Math.abs(nodule.z - slicePos);\n        } else if (currentAxis === 'coronal') {\n          distanceFromSlice = Math.abs(nodule.y - slicePos);\n        } else {\n          // sagittal\n          distanceFromSlice = Math.abs(nodule.x - slicePos);\n        }\n\n        // Calculate the nodule color based on confidence\n        // Always use red for better visibility\n        const color = '#FF0000'; // Bright red color for all nodules\n\n        // Create circle element for nodule outline\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        circle.setAttribute('cx', xPx);\n        circle.setAttribute('cy', yPx);\n        circle.setAttribute('r', radiusPixels);\n        circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)'); // Add slight red fill for better visibility\n        circle.setAttribute('stroke', color);\n        circle.setAttribute('stroke-width', '2');\n        circle.setAttribute('data-nodule-id', nodule.id); // Add nodule ID as data attribute\n\n        // Make nodules interactive - turn off pointer-events: none on the overlay\n        overlay.style.pointerEvents = 'auto';\n\n        // Create dot element for center point\n        const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        centerDot.setAttribute('cx', xPx);\n        centerDot.setAttribute('cy', yPx);\n        centerDot.setAttribute('r', '3');\n        centerDot.setAttribute('fill', color);\n        centerDot.setAttribute('data-nodule-id', nodule.id); // Add nodule ID to center dot too\n\n        // Highlight selected nodule with a thicker stroke\n        if (selectedNoduleState === nodule.id) {\n          circle.setAttribute('stroke-width', '4'); // Thicker for better visibility\n          circle.setAttribute('stroke-dasharray', '5,3');\n          circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)'); // More intense fill for selected nodule\n          centerDot.setAttribute('r', '5'); // Bigger center dot for selected nodule\n        }\n\n        // Add click event listeners to circle and centerDot\n        const handleClick = event => {\n          event.stopPropagation(); // Prevent click from propagating to container\n          const noduleId = event.target.getAttribute('data-nodule-id');\n          if (noduleId) {\n            // Set selected nodule state locally\n            setSelectedNoduleState(noduleId);\n\n            // Call the parent's handler if provided\n            if (onNoduleClick) {\n              onNoduleClick(noduleId);\n            } else {\n              // Otherwise use our own navigation\n              goToNoduleSlice(noduleId);\n            }\n\n            // Redraw nodules to update selection highlighting\n            setTimeout(() => drawNodulesOnImage(), 0);\n          }\n        };\n\n        // Add event listeners\n        circle.addEventListener('click', handleClick);\n        centerDot.addEventListener('click', handleClick);\n\n        // Add tooltip with nodule info\n        const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n        const confidence = nodule.confidence ? (nodule.confidence * 100).toFixed(0) + '%' : 'N/A';\n        const malignancy = nodule.malignancy || 'Unknown';\n        tooltip.textContent = `Nodule ${nodule.id}\\nConfidence: ${confidence}\\nMalignancy: ${malignancy}`;\n        circle.appendChild(tooltip);\n\n        // Add mouseover/mouseout effects for better interaction\n        circle.addEventListener('mouseover', () => {\n          circle.setAttribute('stroke-width', '3');\n          circle.setAttribute('fill', 'rgba(255, 0, 0, 0.3)');\n          centerDot.setAttribute('r', '4');\n        });\n        circle.addEventListener('mouseout', () => {\n          if (selectedNoduleState === nodule.id) {\n            circle.setAttribute('stroke-width', '4');\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)');\n            centerDot.setAttribute('r', '5');\n          } else {\n            circle.setAttribute('stroke-width', '2');\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)');\n            centerDot.setAttribute('r', '3');\n          }\n        });\n        centerDot.addEventListener('mouseover', () => {\n          circle.setAttribute('stroke-width', '3');\n          circle.setAttribute('fill', 'rgba(255, 0, 0, 0.3)');\n          centerDot.setAttribute('r', '4');\n        });\n        centerDot.addEventListener('mouseout', () => {\n          if (selectedNoduleState === nodule.id) {\n            circle.setAttribute('stroke-width', '4');\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)');\n            centerDot.setAttribute('r', '5');\n          } else {\n            circle.setAttribute('stroke-width', '2');\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)');\n            centerDot.setAttribute('r', '3');\n          }\n        });\n        svg.appendChild(circle);\n        svg.appendChild(centerDot);\n      });\n      overlay.appendChild(svg);\n      container.appendChild(overlay);\n    };\n    drawNodules();\n\n    // Cleanup function\n    return () => {\n      const container = containerRef.current;\n      if (container) {\n        const overlay = container.querySelector('.nodule-overlay');\n        if (overlay) {\n          container.removeChild(overlay);\n        }\n      }\n    };\n  }, [sliceImage, nodulesInSlice, currentAxis, selectedNoduleState, volumeInfo, resultsPageView]);\n\n  // Get max slice index for current axis\n  const getMaxSliceIndex = () => {\n    if (!volumeInfo) return 0;\n    try {\n      if (currentAxis === 'axial') {\n        return Math.max(0, volumeInfo.dimensions.depth - 1);\n      } else if (currentAxis === 'coronal') {\n        return Math.max(0, volumeInfo.dimensions.height - 1);\n      } else {\n        // sagittal\n        return Math.max(0, volumeInfo.dimensions.width - 1);\n      }\n    } catch (error) {\n      console.error('Error determining max slice index:', error);\n      return 0;\n    }\n  };\n  const handleAxisChange = axis => {\n    setCurrentAxis(axis);\n    // Reset to middle slice when changing axis\n    if (!volumeInfo) return;\n    let middle;\n    if (axis === 'axial') {\n      middle = Math.floor(volumeInfo.dimensions.depth / 2);\n    } else if (axis === 'coronal') {\n      middle = Math.floor(volumeInfo.dimensions.height / 2);\n    } else {\n      // sagittal\n      middle = Math.floor(volumeInfo.dimensions.width / 2);\n    }\n\n    // Ensure we're setting a valid number, not NaN\n    if (!isNaN(middle) && middle >= 0) {\n      setCurrentSlice(middle);\n    }\n  };\n  const handleSliceChange = e => {\n    const value = parseInt(e.target.value, 10);\n    // Validate before setting\n    if (!isNaN(value) && value >= 0 && value <= getMaxSliceIndex()) {\n      setCurrentSlice(value);\n    }\n  };\n\n  // Track which slices have nodules to highlight them on the slider\n  const slicesWithNodules = () => {\n    if (!volumeInfo || !volumeInfo.nodules) return [];\n\n    // Don't show nodule indicators on the slider in results page view\n    if (resultsPageView) return [];\n    const noduleSlices = new Set();\n    volumeInfo.nodules.forEach(nodule => {\n      if (currentAxis === 'axial') {\n        // Mark all slices within the nodule's radius\n        const start = Math.max(0, Math.floor(nodule.z - nodule.radius));\n        const end = Math.min(volumeInfo.dimensions.depth - 1, Math.ceil(nodule.z + nodule.radius));\n        for (let i = start; i <= end; i++) {\n          noduleSlices.add(i);\n        }\n      } else if (currentAxis === 'coronal') {\n        const start = Math.max(0, Math.floor(nodule.y - nodule.radius));\n        const end = Math.min(volumeInfo.dimensions.height - 1, Math.ceil(nodule.y + nodule.radius));\n        for (let i = start; i <= end; i++) {\n          noduleSlices.add(i);\n        }\n      } else {\n        // sagittal\n        const start = Math.max(0, Math.floor(nodule.x - nodule.radius));\n        const end = Math.min(volumeInfo.dimensions.width - 1, Math.ceil(nodule.x + nodule.radius));\n        for (let i = start; i <= end; i++) {\n          noduleSlices.add(i);\n        }\n      }\n    });\n    return Array.from(noduleSlices);\n  };\n\n  // Nodule colors for different confidence levels\n  const getNoduleColor = confidence => {\n    if (confidence >= 0.8) return 'rgba(220, 38, 38, 0.8)'; // Red for high confidence\n    if (confidence >= 0.6) return 'rgba(234, 88, 12, 0.8)'; // Orange for medium confidence\n    return 'rgba(234, 179, 8, 0.8)'; // Yellow for lower confidence\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `relative w-full h-full ${resultsPageView ? 'results-page-view' : ''}`,\n    ref: containerRef,\n    children: resultsPageView ? /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: isLoading ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex items-center justify-center w-full h-full bg-gray-200\",\n        children: /*#__PURE__*/_jsxDEV(ArrowPathIcon, {\n          className: \"h-8 w-8 animate-spin text-gray-400\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 763,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 762,\n        columnNumber: 13\n      }, this) : error ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex items-center justify-center w-full h-full bg-gray-200\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"text-center p-4\",\n          children: [/*#__PURE__*/_jsxDEV(ExclamationCircleIcon, {\n            className: \"h-8 w-8 mx-auto mb-2 text-red-500\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 768,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n            className: \"text-sm text-gray-600\",\n            children: \"Error loading scan\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 769,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 767,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 766,\n        columnNumber: 13\n      }, this) : sliceImage ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-full h-full overflow-hidden relative\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex items-center justify-center h-full\",\n          children: /*#__PURE__*/_jsxDEV(\"img\", {\n            ref: imageRef,\n            src: sliceImage.data,\n            alt: `Axial view of scan ${caseId}`,\n            className: \"object-contain max-h-full max-w-full\",\n            style: {\n              objectPosition: 'center center',\n              maxHeight: '260px'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 775,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 774,\n          columnNumber: 15\n        }, this), sliceImage.isPlaceholder && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"absolute bottom-0 left-0 right-0 bg-red-500 bg-opacity-70 text-white text-center py-1 text-sm\",\n          children: \"Placeholder Image - Scan Data Unavailable\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 787,\n          columnNumber: 17\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 773,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex items-center justify-center w-full h-full bg-gray-200\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"text-sm text-gray-500\",\n          children: \"No image available\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 794,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 793,\n        columnNumber: 13\n      }, this)\n    }, void 0, false) :\n    /*#__PURE__*/\n    // Original interactive viewer with all controls for the detail page\n    _jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: `absolute top-2 left-2 z-10 rounded-lg shadow-md ${darkMode ? 'bg-gray-800' : 'bg-white'}`,\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex p-1 space-x-1\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAxisChange('axial'),\n            className: `px-3 py-1.5 text-xs font-medium rounded-md ${currentAxis === 'axial' ? darkMode ? 'bg-indigo-600 text-white' : 'bg-indigo-100 text-indigo-700' : darkMode ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-700 hover:bg-gray-100'}`,\n            children: \"Axial\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 804,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAxisChange('coronal'),\n            className: `px-3 py-1.5 text-xs font-medium rounded-md ${currentAxis === 'coronal' ? darkMode ? 'bg-indigo-600 text-white' : 'bg-indigo-100 text-indigo-700' : darkMode ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-700 hover:bg-gray-100'}`,\n            children: \"Coronal\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 818,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAxisChange('sagittal'),\n            className: `px-3 py-1.5 text-xs font-medium rounded-md ${currentAxis === 'sagittal' ? darkMode ? 'bg-indigo-600 text-white' : 'bg-indigo-100 text-indigo-700' : darkMode ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-700 hover:bg-gray-100'}`,\n            children: \"Sagittal\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 832,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 803,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 802,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `absolute bottom-2 left-1/2 transform -translate-x-1/2 z-10 p-2 rounded-lg shadow-md ${darkMode ? 'bg-gray-800' : 'bg-white'}`,\n        style: {\n          width: '90%',\n          maxWidth: '400px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          min: \"0\",\n          max: getMaxSliceIndex(),\n          value: currentSlice,\n          onChange: handleSliceChange,\n          className: \"w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer dark:bg-gray-700\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 851,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex justify-between text-xs mt-1\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: darkMode ? 'text-gray-400' : 'text-gray-500',\n            children: [\"Slice: \", currentSlice + 1, \"/\", getMaxSliceIndex() + 1]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 860,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: darkMode ? 'text-gray-400' : 'text-gray-500',\n            children: [slicesWithNodules().includes(currentSlice) ? 'ðŸ”´ Nodule present' : '', sliceImage && sliceImage.isPlaceholder ? 'âš ï¸ Placeholder' : '']\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 861,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 859,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 850,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-full h-full relative\",\n        children: sliceImage ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"relative w-full h-full\",\n          children: [/*#__PURE__*/_jsxDEV(\"img\", {\n            ref: imageRef,\n            src: sliceImage.data,\n            alt: `${currentAxis.charAt(0).toUpperCase() + currentAxis.slice(1)} slice of CT scan`,\n            className: \"w-full h-full object-contain\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 872,\n            columnNumber: 17\n          }, this), sliceImage.isPlaceholder && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"absolute bottom-0 left-0 right-0 bg-red-500 bg-opacity-70 text-white text-center py-1 text-sm\",\n            children: \"Placeholder Image - Scan Data Unavailable\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 879,\n            columnNumber: 19\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 871,\n          columnNumber: 15\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"flex items-center justify-center w-full h-full bg-gray-200\",\n          children: /*#__PURE__*/_jsxDEV(\"p\", {\n            className: \"text-sm text-gray-500\",\n            children: \"No image available\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 886,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 885,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 869,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 757,\n    columnNumber: 5\n  }, this);\n};\n_s(InteractiveViewer, \"WeiwYs88Yg1ugzj1N6nLC17MWMw=\", false, function () {\n  return [useTheme];\n});\n_c = InteractiveViewer;\nexport default InteractiveViewer;\nvar _c;\n$RefreshReg$(_c, \"InteractiveViewer\");","map":{"version":3,"names":["React","useState","useEffect","useRef","axios","ArrowPathIcon","ExclamationCircleIcon","useTheme","jsxDEV","_jsxDEV","Fragment","_Fragment","InteractiveViewer","caseId","selectedNoduleId","resultsPageView","onNoduleClick","_s","volumeInfo","setVolumeInfo","currentAxis","setCurrentAxis","currentSlice","setCurrentSlice","sliceImage","setSliceImage","isLoading","setIsLoading","error","setError","nodulesInSlice","setNodulesInSlice","selectedNoduleState","setSelectedNoduleState","imageRef","containerRef","darkMode","getAuthToken","localStorage","getItem","createAuthorizedRequest","token","headers","goToNoduleSlice","noduleId","nodules","nodule","find","n","id","console","zSlice","Math","min","max","round","z","getMaxSliceIndex","ySlice","y","xSlice","x","log","fetchVolumeInfo","url","response","get","data","volume_info","usingPlaceholder","using_placeholder","warn","initialSlice","floor","dimensions","depth","length","mainNodule","reduce","prev","current","confidence","selectedNodule","noduleZ","isNaN","height","width","spacing","_error$response","_error$response$data","message","fetchSlice","isPlaceholder","is_placeholder","imageData","slice_data","startsWith","all_dimensions","allDimensions","axial","coronal","sagittal","max_index","undefined","_error$response2","_error$response2$data","_error$response3","_error$response3$data","imgError","sliceNodules","filter","abs","radius","isMhdFormat","endsWith","includes","drawNodules","img","complete","onload","setupNoduleInteractions","drawNodulesOnImage","container","existingOverlay","querySelector","removeChild","overlay","document","createElement","className","style","position","top","left","pointerEvents","addEventListener","event","rect","getBoundingClientRect","clientX","clientY","xNorm","yNorm","imgX","imgY","closestNodule","minDistance","Infinity","forEach","nodeX","nodeY","distance","sqrt","pow","appendChild","imgRect","containerRect","aspectRatio","svg","createElementNS","setAttribute","displayWidth","displayHeight","slicePos","xPx","yPx","radiusMm","pixelsPerMm","spacingX","spacingY","mmPerPixel","widthInMm","spacingZ","heightInMm","radiusPixels","distanceFromSlice","color","circle","centerDot","handleClick","stopPropagation","target","getAttribute","setTimeout","tooltip","toFixed","malignancy","textContent","handleAxisChange","axis","middle","handleSliceChange","e","value","parseInt","slicesWithNodules","noduleSlices","Set","start","end","ceil","i","add","Array","from","getNoduleColor","ref","children","fileName","_jsxFileName","lineNumber","columnNumber","src","alt","objectPosition","maxHeight","onClick","maxWidth","type","onChange","charAt","toUpperCase","slice","_c","$RefreshReg$"],"sources":["C:/Users/kouss/Desktop/Cursor/Segmentation/pipeline/webapp/static/src/components/InteractiveViewer.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport axios from 'axios';\r\nimport { ArrowPathIcon, ExclamationCircleIcon } from '@heroicons/react/24/outline';\r\nimport { useTheme } from '../contexts/ThemeContext';\r\n\r\nconst InteractiveViewer = ({ caseId, selectedNoduleId, resultsPageView = false, onNoduleClick }) => {\r\n  const [volumeInfo, setVolumeInfo] = useState(null);\r\n  const [currentAxis, setCurrentAxis] = useState('axial');\r\n  const [currentSlice, setCurrentSlice] = useState(0);\r\n  const [sliceImage, setSliceImage] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const [nodulesInSlice, setNodulesInSlice] = useState([]);\r\n  const [selectedNoduleState, setSelectedNoduleState] = useState(selectedNoduleId);\r\n  const imageRef = useRef(null);\r\n  const containerRef = useRef(null);\r\n  const { darkMode } = useTheme();\r\n\r\n  // Update local state when prop changes\r\n  useEffect(() => {\r\n    setSelectedNoduleState(selectedNoduleId);\r\n  }, [selectedNoduleId]);\r\n\r\n  // Get the auth token from localStorage\r\n  const getAuthToken = () => {\r\n    return localStorage.getItem('token');\r\n  };\r\n\r\n  // Setup axios request with auth headers\r\n  const createAuthorizedRequest = () => {\r\n    const token = getAuthToken();\r\n    return {\r\n      headers: token ? { 'Authorization': `Bearer ${token}` } : {}\r\n    };\r\n  };\r\n\r\n  // Function to go to a specific nodule slice\r\n  const goToNoduleSlice = (noduleId) => {\r\n    if (!volumeInfo || !volumeInfo.nodules) return;\r\n    \r\n    // Find the selected nodule in the list\r\n    const nodule = volumeInfo.nodules.find(n => n.id === noduleId);\r\n    if (!nodule) {\r\n      console.error(`Nodule with ID ${noduleId} not found`);\r\n      return;\r\n    }\r\n    \r\n    // Update the selected nodule state\r\n    setSelectedNoduleState(noduleId);\r\n    \r\n    // Navigate to appropriate slice based on current view axis\r\n    if (currentAxis === 'axial') {\r\n      // For axial view, go to the Z coordinate of the nodule\r\n      const zSlice = Math.min(Math.max(0, Math.round(nodule.z)), getMaxSliceIndex());\r\n      setCurrentSlice(zSlice);\r\n    } else if (currentAxis === 'coronal') {\r\n      // For coronal view, go to the Y coordinate of the nodule\r\n      const ySlice = Math.min(Math.max(0, Math.round(nodule.y)), getMaxSliceIndex());\r\n      setCurrentSlice(ySlice);\r\n    } else if (currentAxis === 'sagittal') {\r\n      // For sagittal view, go to the X coordinate of the nodule\r\n      const xSlice = Math.min(Math.max(0, Math.round(nodule.x)), getMaxSliceIndex());\r\n      setCurrentSlice(xSlice);\r\n    }\r\n    \r\n    // Log the navigation\r\n    console.log(`Navigated to nodule ${noduleId} at slice ${currentSlice} in ${currentAxis} view`);\r\n  };\r\n\r\n  // Navigate to selected nodule when selectedNoduleId or volumeInfo changes\r\n  useEffect(() => {\r\n    if (selectedNoduleId && volumeInfo && volumeInfo.nodules) {\r\n      goToNoduleSlice(selectedNoduleId);\r\n    }\r\n  }, [selectedNoduleId, volumeInfo]);\r\n\r\n  // Fetch volume metadata\r\n  useEffect(() => {\r\n    const fetchVolumeInfo = async () => {\r\n      try {\r\n        setIsLoading(true);\r\n        \r\n        // Add token to the request\r\n        const token = getAuthToken();\r\n        let url = `/api/results/${caseId}/slices`;\r\n        \r\n        // Add token as query parameter as fallback\r\n        if (token) {\r\n          url += `?token=${token}`;\r\n        }\r\n        \r\n        const response = await axios.get(url, createAuthorizedRequest());\r\n        \r\n        // Check if we received valid volume information\r\n        if (response.data.volume_info) {\r\n          setVolumeInfo(response.data.volume_info);\r\n          \r\n          // Check if we're using placeholder data\r\n          const usingPlaceholder = response.data.using_placeholder || false;\r\n          if (usingPlaceholder) {\r\n            console.warn('Using placeholder data for volume');\r\n          }\r\n          \r\n          // Set initial slice to middle of volume\r\n          const initialSlice = Math.floor(response.data.volume_info.dimensions.depth / 2) || 0;\r\n          setCurrentSlice(initialSlice);\r\n          \r\n          // If we're in a simplified view for the results page and there are nodules,\r\n          // try to show a slice with a nodule if possible\r\n          if (response.data.volume_info.nodules && response.data.volume_info.nodules.length > 0) {\r\n            // Find the slice with the most confident nodule\r\n            const mainNodule = response.data.volume_info.nodules.reduce(\r\n              (prev, current) => (current.confidence > prev.confidence) ? current : prev,\r\n              response.data.volume_info.nodules[0]\r\n            );\r\n            \r\n            // If there's a selected nodule ID and it matches one of our nodules, use that one\r\n            if (selectedNoduleId) {\r\n              const selectedNodule = response.data.volume_info.nodules.find(n => n.id === selectedNoduleId);\r\n              if (selectedNodule) {\r\n                // Ensure we're setting a valid number, not NaN\r\n                const noduleZ = Math.round(selectedNodule.z);\r\n                if (!isNaN(noduleZ) && noduleZ >= 0 && noduleZ < response.data.volume_info.dimensions.depth) {\r\n                  setCurrentSlice(noduleZ);\r\n                  setSelectedNoduleState(selectedNoduleId);\r\n                }\r\n              }\r\n            } \r\n            // Else if no selected nodule or it wasn't found, navigate to the most confident nodule\r\n            else {\r\n              // Ensure we're setting a valid number, not NaN\r\n              const noduleZ = Math.round(mainNodule.z);\r\n              if (!isNaN(noduleZ) && noduleZ >= 0 && noduleZ < response.data.volume_info.dimensions.depth) {\r\n                setCurrentSlice(noduleZ);\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          console.warn('No volume information received from server');\r\n          // Set default volume info to prevent errors\r\n          setVolumeInfo({\r\n            dimensions: { depth: 1, height: 512, width: 512 },\r\n            spacing: [1.0, 1.0, 1.0],\r\n            nodules: []\r\n          });\r\n          setCurrentSlice(0);\r\n        }\r\n        \r\n        setIsLoading(false);\r\n      } catch (error) {\r\n        console.error('Error fetching volume info:', error);\r\n        setError(error.response?.data?.message || 'Failed to load volume data');\r\n        // Set default volume info to prevent errors\r\n        setVolumeInfo({\r\n          dimensions: { depth: 1, height: 512, width: 512 },\r\n          spacing: [1.0, 1.0, 1.0],\r\n          nodules: []\r\n        });\r\n        setCurrentSlice(0);\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchVolumeInfo();\r\n  }, [caseId, resultsPageView]);\r\n\r\n  // Fetch slice when axis or slice index changes\r\n  useEffect(() => {\r\n    const fetchSlice = async () => {\r\n      if (!volumeInfo) return;\r\n      \r\n      try {\r\n        setIsLoading(true);\r\n        \r\n        // Add token to the request\r\n        const token = getAuthToken();\r\n        let url = `/api/results/${caseId}/slices?axis=${currentAxis}&index=${currentSlice}`;\r\n        \r\n        // Add token as query parameter as fallback\r\n        if (token) {\r\n          url += `&token=${token}`;\r\n        }\r\n        \r\n        const response = await axios.get(url, createAuthorizedRequest());\r\n        \r\n        // Check if we received a placeholder image\r\n        const isPlaceholder = response.data.is_placeholder || false;\r\n        \r\n        // Get the slice data, handling whether it includes the data:image prefix or not\r\n        let imageData = response.data.slice_data;\r\n        if (!imageData) {\r\n          console.error('No slice data received');\r\n          setError('No image data received from server');\r\n          setIsLoading(false);\r\n          return;\r\n        }\r\n        \r\n        if (!imageData.startsWith('data:image')) {\r\n          imageData = `data:image/png;base64,${imageData}`;\r\n        }\r\n        \r\n        // Update max dimension information if available\r\n        if (response.data.all_dimensions) {\r\n          // Don't update volumeInfo here as it causes a render loop\r\n          // Just store the dimensions for reference\r\n          const allDimensions = {\r\n            axial: response.data.all_dimensions.axial,\r\n            coronal: response.data.all_dimensions.coronal,\r\n            sagittal: response.data.all_dimensions.sagittal\r\n          };\r\n          \r\n          // Only update the current max index if needed - this won't trigger a re-render\r\n          // since we're not updating the volumeInfo state\r\n          if (allDimensions[currentAxis] && currentSlice > allDimensions[currentAxis] - 1) {\r\n            setCurrentSlice(allDimensions[currentAxis] - 1);\r\n          }\r\n        }\r\n        \r\n        // If max_index is provided, ensure we're not exceeding it\r\n        if (response.data.max_index !== undefined && currentSlice > response.data.max_index) {\r\n          setCurrentSlice(response.data.max_index);\r\n        }\r\n        \r\n        setSliceImage({\r\n          data: imageData,\r\n          isPlaceholder: isPlaceholder\r\n        });\r\n        \r\n        // If there's an error message, display it but still show the image\r\n        if (response.data.error || response.data.message) {\r\n          console.warn('Server returned an error or message:', response.data.error || response.data.message);\r\n        }\r\n        \r\n        setIsLoading(false);\r\n      } catch (error) {\r\n        console.error('Error fetching slice:', error);\r\n        setError(error.response?.data?.message || 'Failed to load slice');\r\n        \r\n        // Try to display error image if available\r\n        if (error.response?.data?.slice_data) {\r\n          try {\r\n            let imageData = error.response.data.slice_data;\r\n            if (!imageData.startsWith('data:image')) {\r\n              imageData = `data:image/png;base64,${imageData}`;\r\n            }\r\n            \r\n            setSliceImage({\r\n              data: imageData,\r\n              isPlaceholder: true\r\n            });\r\n          } catch (imgError) {\r\n            console.error('Error processing error image:', imgError);\r\n          }\r\n        }\r\n        \r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchSlice();\r\n  }, [caseId, currentAxis, currentSlice, volumeInfo]);\r\n\r\n  // Find nodules in the current slice\r\n  useEffect(() => {\r\n    if (!volumeInfo || !volumeInfo.nodules) return;\r\n    \r\n    // Determine which nodules are visible in this slice\r\n    const sliceNodules = volumeInfo.nodules.filter(nodule => {\r\n      // Check if this nodule is visible in the current slice\r\n      if (currentAxis === 'axial') {\r\n        // Check if the nodule's z-coordinate is close to this slice\r\n        return Math.abs(nodule.z - currentSlice) <= nodule.radius;\r\n      } else if (currentAxis === 'coronal') {\r\n        // Check if the nodule's y-coordinate is close to this slice\r\n        return Math.abs(nodule.y - currentSlice) <= nodule.radius;\r\n      } else { // sagittal\r\n        // Check if the nodule's x-coordinate is close to this slice\r\n        return Math.abs(nodule.x - currentSlice) <= nodule.radius;\r\n      }\r\n    });\r\n    \r\n    setNodulesInSlice(sliceNodules);\r\n  }, [volumeInfo, currentAxis, currentSlice]);\r\n\r\n  // Draw nodule circles and center points when image loads or nodulesInSlice changes\r\n  useEffect(() => {\r\n    if (!sliceImage || !imageRef.current || nodulesInSlice.length === 0) return;\r\n    \r\n    // Skip drawing nodules on placeholder images\r\n    if (sliceImage.isPlaceholder) return;\r\n\r\n    // Check if we're using MHD format with server-rendered nodules\r\n    const isMhdFormat = caseId && (\r\n      caseId.endsWith('.mhd') || \r\n      caseId.includes('1.3.6.1.4.1.14519') || // LIDC-IDRI format\r\n      caseId.includes('1.2.826') // DICOM UID format\r\n    );\r\n\r\n    const drawNodules = () => {\r\n      // For MHD files with server-rendered nodules, we may not need to draw client-side\r\n      // Client-side drawing might interfere with server-rendered nodules\r\n      if (isMhdFormat) {\r\n        console.log('Using server-rendered nodules for MHD format');\r\n        // We'll still make the nodules clickable, but won't draw overlays\r\n        const img = imageRef.current;\r\n        if (!img.complete) {\r\n          img.onload = setupNoduleInteractions;\r\n          return;\r\n        }\r\n        setupNoduleInteractions();\r\n        return;\r\n      }\r\n      \r\n      // Normal drawing for non-MHD formats\r\n      const img = imageRef.current;\r\n      if (!img.complete) {\r\n        // Wait for image to load before drawing\r\n        img.onload = drawNodulesOnImage;\r\n        return;\r\n      }\r\n      \r\n      drawNodulesOnImage();\r\n    };\r\n\r\n    // This function just makes nodules clickable without drawing SVG overlays\r\n    const setupNoduleInteractions = () => {\r\n      const img = imageRef.current;\r\n      const container = containerRef.current;\r\n      \r\n      // Create overlay div for event handling\r\n      const existingOverlay = container.querySelector('.nodule-overlay');\r\n      if (existingOverlay) {\r\n        container.removeChild(existingOverlay);\r\n      }\r\n      \r\n      // Create a minimal overlay just for handling clicks\r\n      const overlay = document.createElement('div');\r\n      overlay.className = 'nodule-overlay';\r\n      overlay.style.position = 'absolute';\r\n      overlay.style.top = '0';\r\n      overlay.style.left = '0';\r\n      overlay.style.width = '100%';\r\n      overlay.style.height = '100%';\r\n      overlay.style.pointerEvents = 'auto';\r\n      \r\n      // Add click handler for the whole image\r\n      overlay.addEventListener('click', (event) => {\r\n        // Get click coordinates relative to the image\r\n        const rect = img.getBoundingClientRect();\r\n        const x = event.clientX - rect.left;\r\n        const y = event.clientY - rect.top;\r\n        \r\n        // Normalize to 0-1 range\r\n        const xNorm = x / rect.width;\r\n        const yNorm = y / rect.height;\r\n        \r\n        // Convert to image coordinates\r\n        const imgX = Math.round(xNorm * volumeInfo.dimensions.width);\r\n        const imgY = Math.round(yNorm * volumeInfo.dimensions.height);\r\n        \r\n        // Find closest nodule to click point\r\n        let closestNodule = null;\r\n        let minDistance = Infinity;\r\n        \r\n        nodulesInSlice.forEach(nodule => {\r\n          let nodeX, nodeY;\r\n          \r\n          if (currentAxis === 'axial') {\r\n            nodeX = nodule.x;\r\n            nodeY = nodule.y;\r\n          } else if (currentAxis === 'coronal') {\r\n            nodeX = nodule.x;\r\n            nodeY = nodule.z;\r\n          } else { // sagittal\r\n            nodeX = nodule.y;\r\n            nodeY = nodule.z;\r\n          }\r\n          \r\n          const distance = Math.sqrt(\r\n            Math.pow(nodeX - imgX, 2) + \r\n            Math.pow(nodeY - imgY, 2)\r\n          );\r\n          \r\n          // Consider a nodule clicked if within 30px of its center\r\n          if (distance < nodule.radius * 2 && distance < minDistance) {\r\n            minDistance = distance;\r\n            closestNodule = nodule;\r\n          }\r\n        });\r\n        \r\n        if (closestNodule) {\r\n          setSelectedNoduleState(closestNodule.id);\r\n          \r\n          if (onNoduleClick) {\r\n            onNoduleClick(closestNodule.id);\r\n          } else {\r\n            goToNoduleSlice(closestNodule.id);\r\n          }\r\n        }\r\n      });\r\n      \r\n      container.appendChild(overlay);\r\n    };\r\n\r\n    // Original function for drawing nodules with SVG overlays\r\n    const drawNodulesOnImage = () => {\r\n      const img = imageRef.current;\r\n      const container = containerRef.current;\r\n      \r\n      // Clear any existing overlay elements\r\n      const existingOverlay = container.querySelector('.nodule-overlay');\r\n      if (existingOverlay) {\r\n        container.removeChild(existingOverlay);\r\n      }\r\n      \r\n      // Create overlay div that will contain the SVG with nodule circles\r\n      const overlay = document.createElement('div');\r\n      overlay.className = 'nodule-overlay';\r\n      overlay.style.position = 'absolute';\r\n      overlay.style.top = '0';\r\n      overlay.style.left = '0';\r\n      overlay.style.width = '100%';\r\n      overlay.style.height = '100%';\r\n      overlay.style.pointerEvents = 'auto';\r\n      \r\n      // Calculate image display dimensions and position\r\n      const imgRect = img.getBoundingClientRect();\r\n      const containerRect = container.getBoundingClientRect();\r\n      \r\n      // Calculate aspect ratio for the current view\r\n      let aspectRatio = 1.0;\r\n      if (volumeInfo && volumeInfo.spacing) {\r\n        if (currentAxis === 'axial') {\r\n          // Y/X aspect ratio for axial view\r\n          aspectRatio = volumeInfo.spacing[1] / volumeInfo.spacing[0];\r\n        } else if (currentAxis === 'coronal') {\r\n          // Z/X aspect ratio for coronal view\r\n          aspectRatio = volumeInfo.spacing[2] / volumeInfo.spacing[0];\r\n        } else { // sagittal\r\n          // Z/Y aspect ratio for sagittal view\r\n          aspectRatio = volumeInfo.spacing[2] / volumeInfo.spacing[1];\r\n        }\r\n      }\r\n      \r\n      // Create SVG element for drawing\r\n      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n      svg.setAttribute('width', '100%');\r\n      svg.setAttribute('height', '100%');\r\n      svg.style.position = 'absolute';\r\n      svg.style.top = '0';\r\n      svg.style.left = '0';\r\n      \r\n      // Get display dimensions for scaling\r\n      const displayWidth = imgRect.width;\r\n      const displayHeight = imgRect.height;\r\n      \r\n      // Draw each nodule\r\n      nodulesInSlice.forEach(nodule => {\r\n        let x, y, slicePos;\r\n        \r\n        // Calculate 2D coordinates based on the current viewing axis\r\n        if (currentAxis === 'axial') {\r\n          x = nodule.x;\r\n          y = nodule.y;\r\n          slicePos = currentSlice;\r\n        } else if (currentAxis === 'coronal') {\r\n          x = nodule.x;\r\n          y = nodule.z;\r\n          slicePos = currentSlice;\r\n        } else { // sagittal\r\n          x = nodule.y;\r\n          y = nodule.z;\r\n          slicePos = currentSlice;\r\n        }\r\n        \r\n        // Calculate the position in normalized coordinates (0-1 range)\r\n        let xNorm, yNorm;\r\n        \r\n        if (currentAxis === 'axial') {\r\n          xNorm = x / volumeInfo.dimensions.width;\r\n          yNorm = y / volumeInfo.dimensions.height;\r\n        } else if (currentAxis === 'coronal') {\r\n          xNorm = x / volumeInfo.dimensions.width;\r\n          yNorm = y / volumeInfo.dimensions.depth;\r\n        } else { // sagittal\r\n          xNorm = y / volumeInfo.dimensions.height;\r\n          yNorm = nodule.z / volumeInfo.dimensions.depth;\r\n        }\r\n        \r\n        // Apply proper scaling for the current view resolution\r\n        // Convert from normalized coordinates to display pixels\r\n        const xPx = xNorm * displayWidth;\r\n        \r\n        // Apply aspect ratio correction to y-coordinate\r\n        // This ensures that the nodule appears at the right vertical position\r\n        // regardless of how the image is stretched or squeezed\r\n        const yPx = yNorm * displayHeight;\r\n        \r\n        // Calculate radius in pixels based on the nodule's radius in mm\r\n        // Scale according to the current display size\r\n        let radiusMm = nodule.radius || 5; // Default to 5mm if not specified\r\n        let pixelsPerMm;\r\n        \r\n        // Calculate pixels per mm based on the current view's spacing\r\n        if (currentAxis === 'axial') {\r\n          // Use the minimum of width and height spacing for consistent sizing\r\n          const spacingX = volumeInfo.spacing ? volumeInfo.spacing[0] : 1;\r\n          const spacingY = volumeInfo.spacing ? volumeInfo.spacing[1] : 1;\r\n          const mmPerPixel = Math.min(spacingX, spacingY);\r\n          // Calculate how many display pixels correspond to one mm in the CT scan\r\n          const widthInMm = volumeInfo.dimensions.width * spacingX;\r\n          pixelsPerMm = displayWidth / widthInMm;\r\n        } else if (currentAxis === 'coronal') {\r\n          const spacingX = volumeInfo.spacing ? volumeInfo.spacing[0] : 1;\r\n          const spacingZ = volumeInfo.spacing ? volumeInfo.spacing[2] : 1;\r\n          const mmPerPixel = Math.min(spacingX, spacingZ);\r\n          // Calculate how many display pixels correspond to one mm in the CT scan\r\n          const widthInMm = volumeInfo.dimensions.width * spacingX;\r\n          pixelsPerMm = displayWidth / widthInMm;\r\n        } else { // sagittal\r\n          const spacingY = volumeInfo.spacing ? volumeInfo.spacing[1] : 1;\r\n          const spacingZ = volumeInfo.spacing ? volumeInfo.spacing[2] : 1;\r\n          const mmPerPixel = Math.min(spacingY, spacingZ);\r\n          // Calculate how many display pixels correspond to one mm in the CT scan\r\n          const heightInMm = volumeInfo.dimensions.height * spacingY;\r\n          pixelsPerMm = displayHeight / heightInMm;\r\n        }\r\n        \r\n        // Calculate the radius in display pixels\r\n        let radiusPixels = radiusMm * pixelsPerMm;\r\n        \r\n        // Make circles more appropriately sized for visualization\r\n        radiusPixels = Math.max(5, radiusPixels * 0.5); // Minimum 5px radius for visibility\r\n        \r\n        // Adjust the radius based on how far the nodule is from the current slice\r\n        let distanceFromSlice;\r\n        if (currentAxis === 'axial') {\r\n          distanceFromSlice = Math.abs(nodule.z - slicePos);\r\n        } else if (currentAxis === 'coronal') {\r\n          distanceFromSlice = Math.abs(nodule.y - slicePos);\r\n        } else { // sagittal\r\n          distanceFromSlice = Math.abs(nodule.x - slicePos);\r\n        }\r\n        \r\n        // Calculate the nodule color based on confidence\r\n        // Always use red for better visibility\r\n        const color = '#FF0000'; // Bright red color for all nodules\r\n        \r\n        // Create circle element for nodule outline\r\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        circle.setAttribute('cx', xPx);\r\n        circle.setAttribute('cy', yPx);\r\n        circle.setAttribute('r', radiusPixels);\r\n        circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)'); // Add slight red fill for better visibility\r\n        circle.setAttribute('stroke', color);\r\n        circle.setAttribute('stroke-width', '2');\r\n        circle.setAttribute('data-nodule-id', nodule.id); // Add nodule ID as data attribute\r\n        \r\n        // Make nodules interactive - turn off pointer-events: none on the overlay\r\n        overlay.style.pointerEvents = 'auto';\r\n        \r\n        // Create dot element for center point\r\n        const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        centerDot.setAttribute('cx', xPx);\r\n        centerDot.setAttribute('cy', yPx);\r\n        centerDot.setAttribute('r', '3');\r\n        centerDot.setAttribute('fill', color);\r\n        centerDot.setAttribute('data-nodule-id', nodule.id); // Add nodule ID to center dot too\r\n        \r\n        // Highlight selected nodule with a thicker stroke\r\n        if (selectedNoduleState === nodule.id) {\r\n            circle.setAttribute('stroke-width', '4');  // Thicker for better visibility\r\n            circle.setAttribute('stroke-dasharray', '5,3');\r\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)'); // More intense fill for selected nodule\r\n            centerDot.setAttribute('r', '5'); // Bigger center dot for selected nodule\r\n        }\r\n        \r\n        // Add click event listeners to circle and centerDot\r\n        const handleClick = (event) => {\r\n            event.stopPropagation(); // Prevent click from propagating to container\r\n            const noduleId = event.target.getAttribute('data-nodule-id');\r\n            if (noduleId) {\r\n                // Set selected nodule state locally\r\n                setSelectedNoduleState(noduleId);\r\n                \r\n                // Call the parent's handler if provided\r\n                if (onNoduleClick) {\r\n                    onNoduleClick(noduleId);\r\n                } else {\r\n                    // Otherwise use our own navigation\r\n                    goToNoduleSlice(noduleId);\r\n                }\r\n                \r\n                // Redraw nodules to update selection highlighting\r\n                setTimeout(() => drawNodulesOnImage(), 0);\r\n            }\r\n        };\r\n        \r\n        // Add event listeners\r\n        circle.addEventListener('click', handleClick);\r\n        centerDot.addEventListener('click', handleClick);\r\n        \r\n        // Add tooltip with nodule info\r\n        const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'title');\r\n        const confidence = nodule.confidence ? (nodule.confidence * 100).toFixed(0) + '%' : 'N/A';\r\n        const malignancy = nodule.malignancy || 'Unknown';\r\n        tooltip.textContent = `Nodule ${nodule.id}\\nConfidence: ${confidence}\\nMalignancy: ${malignancy}`;\r\n        circle.appendChild(tooltip);\r\n        \r\n        // Add mouseover/mouseout effects for better interaction\r\n        circle.addEventListener('mouseover', () => {\r\n            circle.setAttribute('stroke-width', '3');\r\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.3)');\r\n            centerDot.setAttribute('r', '4');\r\n        });\r\n        \r\n        circle.addEventListener('mouseout', () => {\r\n            if (selectedNoduleState === nodule.id) {\r\n                circle.setAttribute('stroke-width', '4');\r\n                circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)');\r\n                centerDot.setAttribute('r', '5');\r\n            } else {\r\n                circle.setAttribute('stroke-width', '2');\r\n                circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)');\r\n                centerDot.setAttribute('r', '3');\r\n            }\r\n        });\r\n        \r\n        centerDot.addEventListener('mouseover', () => {\r\n            circle.setAttribute('stroke-width', '3');\r\n            circle.setAttribute('fill', 'rgba(255, 0, 0, 0.3)');\r\n            centerDot.setAttribute('r', '4');\r\n        });\r\n        \r\n        centerDot.addEventListener('mouseout', () => {\r\n            if (selectedNoduleState === nodule.id) {\r\n                circle.setAttribute('stroke-width', '4');\r\n                circle.setAttribute('fill', 'rgba(255, 0, 0, 0.35)');\r\n                centerDot.setAttribute('r', '5');\r\n            } else {\r\n                circle.setAttribute('stroke-width', '2');\r\n                circle.setAttribute('fill', 'rgba(255, 0, 0, 0.2)');\r\n                centerDot.setAttribute('r', '3');\r\n            }\r\n        });\r\n        \r\n        svg.appendChild(circle);\r\n        svg.appendChild(centerDot);\r\n      });\r\n      \r\n      overlay.appendChild(svg);\r\n      container.appendChild(overlay);\r\n    };\r\n\r\n    drawNodules();\r\n    \r\n    // Cleanup function\r\n    return () => {\r\n      const container = containerRef.current;\r\n      if (container) {\r\n        const overlay = container.querySelector('.nodule-overlay');\r\n        if (overlay) {\r\n          container.removeChild(overlay);\r\n        }\r\n      }\r\n    };\r\n  }, [sliceImage, nodulesInSlice, currentAxis, selectedNoduleState, volumeInfo, resultsPageView]);\r\n\r\n  // Get max slice index for current axis\r\n  const getMaxSliceIndex = () => {\r\n    if (!volumeInfo) return 0;\r\n    \r\n    try {\r\n      if (currentAxis === 'axial') {\r\n        return Math.max(0, volumeInfo.dimensions.depth - 1);\r\n      } else if (currentAxis === 'coronal') {\r\n        return Math.max(0, volumeInfo.dimensions.height - 1);\r\n      } else { // sagittal\r\n        return Math.max(0, volumeInfo.dimensions.width - 1);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error determining max slice index:', error);\r\n      return 0;\r\n    }\r\n  };\r\n\r\n  const handleAxisChange = (axis) => {\r\n    setCurrentAxis(axis);\r\n    // Reset to middle slice when changing axis\r\n    if (!volumeInfo) return;\r\n    \r\n    let middle;\r\n    if (axis === 'axial') {\r\n      middle = Math.floor(volumeInfo.dimensions.depth / 2);\r\n    } else if (axis === 'coronal') {\r\n      middle = Math.floor(volumeInfo.dimensions.height / 2);\r\n    } else { // sagittal\r\n      middle = Math.floor(volumeInfo.dimensions.width / 2);\r\n    }\r\n    \r\n    // Ensure we're setting a valid number, not NaN\r\n    if (!isNaN(middle) && middle >= 0) {\r\n      setCurrentSlice(middle);\r\n    }\r\n  };\r\n\r\n  const handleSliceChange = (e) => {\r\n    const value = parseInt(e.target.value, 10);\r\n    // Validate before setting\r\n    if (!isNaN(value) && value >= 0 && value <= getMaxSliceIndex()) {\r\n      setCurrentSlice(value);\r\n    }\r\n  };\r\n\r\n  // Track which slices have nodules to highlight them on the slider\r\n  const slicesWithNodules = () => {\r\n    if (!volumeInfo || !volumeInfo.nodules) return [];\r\n    \r\n    // Don't show nodule indicators on the slider in results page view\r\n    if (resultsPageView) return [];\r\n    \r\n    const noduleSlices = new Set();\r\n    volumeInfo.nodules.forEach(nodule => {\r\n      if (currentAxis === 'axial') {\r\n        // Mark all slices within the nodule's radius\r\n        const start = Math.max(0, Math.floor(nodule.z - nodule.radius));\r\n        const end = Math.min(volumeInfo.dimensions.depth - 1, Math.ceil(nodule.z + nodule.radius));\r\n        for (let i = start; i <= end; i++) {\r\n          noduleSlices.add(i);\r\n        }\r\n      } else if (currentAxis === 'coronal') {\r\n        const start = Math.max(0, Math.floor(nodule.y - nodule.radius));\r\n        const end = Math.min(volumeInfo.dimensions.height - 1, Math.ceil(nodule.y + nodule.radius));\r\n        for (let i = start; i <= end; i++) {\r\n          noduleSlices.add(i);\r\n        }\r\n      } else { // sagittal\r\n        const start = Math.max(0, Math.floor(nodule.x - nodule.radius));\r\n        const end = Math.min(volumeInfo.dimensions.width - 1, Math.ceil(nodule.x + nodule.radius));\r\n        for (let i = start; i <= end; i++) {\r\n          noduleSlices.add(i);\r\n        }\r\n      }\r\n    });\r\n    \r\n    return Array.from(noduleSlices);\r\n  };\r\n\r\n  // Nodule colors for different confidence levels\r\n  const getNoduleColor = (confidence) => {\r\n    if (confidence >= 0.8) return 'rgba(220, 38, 38, 0.8)';  // Red for high confidence\r\n    if (confidence >= 0.6) return 'rgba(234, 88, 12, 0.8)';  // Orange for medium confidence\r\n    return 'rgba(234, 179, 8, 0.8)';  // Yellow for lower confidence\r\n  };\r\n\r\n  return (\r\n    <div className={`relative w-full h-full ${resultsPageView ? 'results-page-view' : ''}`} ref={containerRef}>\r\n      {/* If in results page mode, only show the image without controls */}\r\n      {resultsPageView ? (\r\n        <>\r\n          {isLoading ? (\r\n            <div className=\"flex items-center justify-center w-full h-full bg-gray-200\">\r\n              <ArrowPathIcon className=\"h-8 w-8 animate-spin text-gray-400\" />\r\n            </div>\r\n          ) : error ? (\r\n            <div className=\"flex items-center justify-center w-full h-full bg-gray-200\">\r\n              <div className=\"text-center p-4\">\r\n                <ExclamationCircleIcon className=\"h-8 w-8 mx-auto mb-2 text-red-500\" />\r\n                <p className=\"text-sm text-gray-600\">Error loading scan</p>\r\n              </div>\r\n            </div>\r\n          ) : sliceImage ? (\r\n            <div className=\"w-full h-full overflow-hidden relative\">\r\n              <div className=\"flex items-center justify-center h-full\">\r\n                <img \r\n                  ref={imageRef}\r\n                  src={sliceImage.data} \r\n                  alt={`Axial view of scan ${caseId}`}\r\n                  className=\"object-contain max-h-full max-w-full\"\r\n                  style={{ \r\n                    objectPosition: 'center center',\r\n                    maxHeight: '260px'\r\n                  }}\r\n                />\r\n              </div>\r\n              {sliceImage.isPlaceholder && (\r\n                <div className=\"absolute bottom-0 left-0 right-0 bg-red-500 bg-opacity-70 text-white text-center py-1 text-sm\">\r\n                  Placeholder Image - Scan Data Unavailable\r\n                </div>\r\n              )}\r\n            </div>\r\n          ) : (\r\n            <div className=\"flex items-center justify-center w-full h-full bg-gray-200\">\r\n              <p className=\"text-sm text-gray-500\">No image available</p>\r\n            </div>\r\n          )}\r\n        </>\r\n      ) : (\r\n        // Original interactive viewer with all controls for the detail page\r\n        <>\r\n          {/* Axis selection */}\r\n          <div className={`absolute top-2 left-2 z-10 rounded-lg shadow-md ${darkMode ? 'bg-gray-800' : 'bg-white'}`}>\r\n            <div className=\"flex p-1 space-x-1\">\r\n              <button\r\n                onClick={() => handleAxisChange('axial')}\r\n                className={`px-3 py-1.5 text-xs font-medium rounded-md ${\r\n                  currentAxis === 'axial' \r\n                    ? darkMode\r\n                      ? 'bg-indigo-600 text-white'\r\n                      : 'bg-indigo-100 text-indigo-700'\r\n                    : darkMode\r\n                      ? 'text-gray-300 hover:bg-gray-700'\r\n                      : 'text-gray-700 hover:bg-gray-100'\r\n                }`}\r\n              >\r\n                Axial\r\n              </button>\r\n              <button\r\n                onClick={() => handleAxisChange('coronal')}\r\n                className={`px-3 py-1.5 text-xs font-medium rounded-md ${\r\n                  currentAxis === 'coronal' \r\n                    ? darkMode\r\n                      ? 'bg-indigo-600 text-white'\r\n                      : 'bg-indigo-100 text-indigo-700'\r\n                    : darkMode\r\n                      ? 'text-gray-300 hover:bg-gray-700'\r\n                      : 'text-gray-700 hover:bg-gray-100'\r\n                }`}\r\n              >\r\n                Coronal\r\n              </button>\r\n              <button\r\n                onClick={() => handleAxisChange('sagittal')}\r\n                className={`px-3 py-1.5 text-xs font-medium rounded-md ${\r\n                  currentAxis === 'sagittal' \r\n                    ? darkMode\r\n                      ? 'bg-indigo-600 text-white'\r\n                      : 'bg-indigo-100 text-indigo-700'\r\n                    : darkMode\r\n                      ? 'text-gray-300 hover:bg-gray-700'\r\n                      : 'text-gray-700 hover:bg-gray-100'\r\n                }`}\r\n              >\r\n                Sagittal\r\n              </button>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Slice slider */}\r\n          <div className={`absolute bottom-2 left-1/2 transform -translate-x-1/2 z-10 p-2 rounded-lg shadow-md ${darkMode ? 'bg-gray-800' : 'bg-white'}`} style={{ width: '90%', maxWidth: '400px' }}>\r\n            <input \r\n              type=\"range\"\r\n              min=\"0\"\r\n              max={getMaxSliceIndex()}\r\n              value={currentSlice}\r\n              onChange={handleSliceChange}\r\n              className=\"w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer dark:bg-gray-700\"\r\n            />\r\n            <div className=\"flex justify-between text-xs mt-1\">\r\n              <span className={darkMode ? 'text-gray-400' : 'text-gray-500'}>Slice: {currentSlice + 1}/{getMaxSliceIndex() + 1}</span>\r\n              <span className={darkMode ? 'text-gray-400' : 'text-gray-500'}>\r\n                {slicesWithNodules().includes(currentSlice) ? 'ðŸ”´ Nodule present' : ''}\r\n                {sliceImage && sliceImage.isPlaceholder ? 'âš ï¸ Placeholder' : ''}\r\n              </span>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Main image display */}\r\n          <div className=\"w-full h-full relative\">\r\n            {sliceImage ? (\r\n              <div className=\"relative w-full h-full\">\r\n                <img \r\n                  ref={imageRef}\r\n                  src={sliceImage.data} \r\n                  alt={`${currentAxis.charAt(0).toUpperCase() + currentAxis.slice(1)} slice of CT scan`}\r\n                  className=\"w-full h-full object-contain\"\r\n                />\r\n                {sliceImage.isPlaceholder && (\r\n                  <div className=\"absolute bottom-0 left-0 right-0 bg-red-500 bg-opacity-70 text-white text-center py-1 text-sm\">\r\n                    Placeholder Image - Scan Data Unavailable\r\n                  </div>\r\n                )}\r\n              </div>\r\n            ) : (\r\n              <div className=\"flex items-center justify-center w-full h-full bg-gray-200\">\r\n                <p className=\"text-sm text-gray-500\">No image available</p>\r\n              </div>\r\n            )}\r\n          </div>\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default InteractiveViewer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}